
# 类加载过程

1. 加载

   通过一个类的完全限定查找此类字节码文件，把此文件读入到java虚拟机中，并利用此文件创建一个Class对象

2. 连接
  
   将已经读入到内存的类的二进制数据合并到虚拟机的运行时环境中去

    - 验证
      目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身安全。主要包括四种验证，文件结构验证，语义检查，字节码验证，二进制验证。
    - 准备
      为类变量(即static修饰的字段变量)分配内存并且设置该类变量的初始值即零值(0，null，false)，这里不包含用final修饰的static，因为final在编译的时候就会分配了。注意这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中。
    - 解析
      主要将常量池中的符号引用替换为直接引用的过程。符号引用就是一组符号来描述目标，可以是任何字面量，而直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。有类或接口的解析，字段解析，类方法解析，接口方法解析。


3. 初始化

   类加载最后阶段，java虚拟机实现必须在每个类或接口首次**主动使用**时初始化。

   1. 若该类还没有被加载和连接，那就先进行加载和连接
   2. 若该类具有超类（父类），并且还没有被初始化，则对其进行初始化 (不包括接口)
   3. 若该类中存在初始化语句（定义初的赋值，静态代码块），则依次执行这些初始化语句。(如前面只初始化了默认值的static变量将会在这个阶段赋值，成员变量也将被初始化)。

# 主动使用

1. 创建类的实例
2. 访问或赋值某个类（接口）的静态变量
3. 调用类的静态方法
4. 反射（如`Class.forName("com.test.Test")`）
5. 初始化一个类的子类
6. Java虚拟机启动时被标明为启动类的类（main 、javaTest）
7. JDK1.7开始提供的动态语言支持：`java.lang.invoke.MethodHandle`实例的解析结果`REF_getStatic`,`REF_putStatic`,`REF_invokeStatic`句柄对应的类没有初始化，则初始化

**注意**：

1. 只有当程序访问的静态变量或静态方法确实是在当前类或接口定义时，才可以认为是对该类或接口的主动使用
2. 一个父接口不会因为它的子接口或者实现类的初始化而初始化，只有当程序首次使用该接口的静态变量时，才会导致该接口的初始化
3. 调用`classLoader`类的`loadClass`方法加载一个类，不是主动使用，不会导致类的初始化

# 类加载器

1. jvm自带的类加载器
   1. 根加载器 bootstrap -- `<JAVA_HOME>/lib`下核心Java库或`-Xbootclasspath`参数指定的路径下的jar包
   2. 扩展类加载器 extension --` <JAVA_HOME>/jre/lib/ext/*.jar`或由系统变量`-Djava.ext.dir`指定位路径中的类库
   3. 系统（应用）类加载器 system -- 系统类路径`java -classpath`或`-D java.class.path` 指定路径下的类库
2. 用户自定义的类加载器
   1. `java.lang.ClassLoader`的子类
   2. 用户可以定制类的加载方式

- 内建于jvm中的启动类加载器（bootstrap）会加载java.lang.ClassLoader以及其他的java平台类。
- 启动类加载器是特定于平台的机器指令，负责开启整个加载过程。
- 启动类加载器并不是java类，其他加载器都是java类。

JVM规范允许类加载器预料某个类将被使用时预先加载某个类，并不需要等到某个类被**首次主动使用**时再加载。如果遇到 `.class` 文件缺失或者错误，类加载器必须在程序首次主动使用该类时才报告错误 `LinkageError` ，如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误。

数组对象不是由加载器加载的，是java运行时自动创建的，若是使用getClassLoader方法，返回的是element的ClassLoader，若element是原生类型（`byte` `short` `int` `long` `float` `double` `boolean` `char`），则没有ClassLoader，返回null。

## 命名空间

每个类加载器都有自己的命名空间，命令空间由该加载器及所有父加载器所加载的类组成。
同一个命令空间中，不会出现类的完整名字相同的两个类。
不同的命令空间中，有可能出现类的完整名字相同的两个类。
子加载器加载的类能访问父加载器所加载的类，反之则不行。ps:高处不胜寒

jvm自带的类加载器加载的类是不会被卸载的，因为jvm本身会始终引用这些类加载器。


---
#jvm  #java