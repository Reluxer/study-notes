#Bipartite Graph#

##定义##

二分图(Bipartite Graph)又称作**二部图**，是图论中的一种特殊模型。 设`G=(V,E)`是一个无向图，如果顶点`V`可分割为两个互不相交的子集`(A,B)`，并且图中的每条边`（i，j）`所关联的两个顶点i和j分别属于这两个不同的顶点集`(i in A,j in B)`，则称图G为一个二分图。
 
《组合数学》上这样讲解：
>  二分图可描述为：一，顶点的集合；二，将该顶点集分成两部分的一个划分；三，连接一部分的一个顶点与另一部分的一个顶点的边的集合。

简而言之，就是顶点集V可分割为两个互不相交的子集，并且图中每条边依附的两个顶点都分属于这两个互不相交的子集。

##充要条件##

无向图G为二分图的充分必要条件是，G至少有两个顶点，且其所有回路的长度均为偶数。  
常见方法：**染色法**，开始对任意一未染色的顶点染色，之后判断其相邻的顶点中，若未染色则将其染上和相邻顶点不同的颜色，若已经染色且颜色和相邻顶点的颜色相同则说明不是二分图，若颜色不同则继续判断，用深搜，广搜都可以。

	bool isBipartiteGraph()
	{
    	memset(color, -1, sizeof(color));
    	//将每个点的染色状态初始化，-1为未染色
    	for(int j = 1; j <= n; j++){
        	if(color[j] != -1) continue;
        	queue<int> q;
        	color[j] = 1;
        	q.push(j);
        	while(!q.empty()){
            	int k = q.front();
            	q.pop();
            	for(int i = 1; i <= n; i++){
                	if(g[k][i] && color[i] == color[k])
                    	return false;
                	if(g[k][i] && color[i] == -1){
                    	q.push(i);
                    	color[i] = 1 - color[k];
                	}
            	}
        	}
    	}
    	return true;
	}

##最大匹配##

###定义###

>  给定一个二分图G，M为G边集的一个子集，如果M满足当中的任意两条边都不依附于同一个顶点，则称M是一个匹配。图
   中包含边数最多的匹配称为图的最大匹配。

###相关知识###

**增广路径**的定义(也称增广轨或交错轨)：若P是图G中一条连通两个未匹配顶点的路径，并且属M的边和不属M的边(即已匹配和待匹配的边)在P上交替出现，则称P为相对于M的一条增广路径。
由增广路径的定义可以推出下述4个结论：  

- P的路径长度必定为奇数，第一条边和最后一条边都不属于M。
- P上所有第奇数条边都不在M中，所有第偶数条边都出现在M中。
- P经过取反操作可以得到一个更大的匹配M’。所谓“取反”即把P上所有第奇数条边(原不在M中)加入到M中，并把P中所有第偶数条边(原在M中)从M中删除，则新的匹配数就比原匹配数多了1个。（增广路顾名思义就是使匹配数增多的路径）
- M为G的最大匹配当且仅当不存在相对于M的增广路径。

寻找最大匹配的核心问题就是找增广路径(augment path)。基本模式就是：  

	初始时最大匹配为空
	while 找得到增广路径
		do 把增广路径加入到最大匹配中去

###三个重要结论###

1. **最小点覆盖数＝最大匹配数**  
最小点覆盖数：假如选了一个点就相当于覆盖了以它为端点的所有边，你需要选择最少的点来覆盖所有的边。  
**König定理**是一个二分图中很重要的定理，它的意思是，一个二分图中的最大匹配数等于这个图中的最小点覆盖数。[证明](http://www.matrix67.com/blog/archives/116)

2. **最小路径覆盖＝｜N｜- 最大匹配数**  
	在一个N*N的有向图中，路径覆盖就是在图中找一些路经，使之覆盖了图中的所有顶点，且任何一个顶点有且只有一条路径与之关联；
（如果把这些路径中的每条路径从它的起始点走到它的终点，那么恰好可以经过图中的每个顶点一次且仅一次）；
如果不考虑图中存在回路，那么每条路径就是一个弱连通子集．  
由上面可以得出：
	1. 一个单独的顶点是一条路径；
	2. 如果存在一路径p1,p2,......,pk，其中p1 为起点，pk为终点，那么在覆盖图中，顶点p1,p2,......,pk不再与其它的顶点之间存在有向边。  

	最小路径覆盖就是找出最小的路径条数，使之成为G的一个路径覆盖．
	解决此类问题可以建立一个二分图模型。把所有顶点i拆成两个：X结点集中的i和Y结点集中的i'，如果有边i->j，则在二分图中引入边i->j'，设二分图最大匹配为m，则结果就是n-m。

3. **二分图最大独立集=顶点数 - 二分图最大匹配**  
二分图最大独立集:在Ｎ个点的图G中选出m个点，使这m个点两两之间没有边，求m最大值。  
如果图Ｇ满足二分图条件，则可以用二分图匹配来做．最大独立集点数 = N - 最大匹配数。

###最大匹配模板###

1. 匈牙利算法

		/**************************************************************
		//二分图匹配（匈牙利算法的DFS实现）
		//初始化：g[][]两边顶点的划分情况
		//建立g[i][j]表示i->j的有向边就可以了，是左边向右边的匹配
		//g没有边相连则初始化为0
		//uN是匹配左边的顶点数，vN是匹配右边的顶点数
		//调用：res=hungary();输出最大匹配数
		//优点：适用于稠密图，DFS找增广路，实现简洁易于理解
		//时间复杂度:O(VE)
		//*************************************************************/
		//顶点编号从0开始的
		const int MAXN=510;
		int uN,vN;//u,v数目
		int g[MAXN][MAXN];
		int linker[MAXN];
		bool used[MAXN];
		bool dfs(int u)//从左边开始找增广路径
		{
    		int v;
    		for(v=0;v<vN;v++)//这个顶点编号从0开始，若要从1开始需要修改
      		if(g[u][v]&&!used[v])
      		{
          		used[v]=true;
          		if(linker[v]==-1||dfs(linker[v])) //如果i未在前一个匹配M中，
						//或者i在匹配M中，但是从与i相邻的节点出发可以有增广路径
          		{
              		linker[v]=u; //记录查找成功记录，更新匹配M（即“取反”）
              		return true;
          		}
      		}
    		return false;//这个不要忘了，经常忘记这句
		}
		int hungary()
		{
    		int res=0;
    		int u;
    		memset(linker,-1,sizeof(linker));
    		for(u=0;u<uN;u++)
    		{
        		memset(used,0,sizeof(used));//清空上次搜索时的标记
        		if(dfs(u)) res++;//从节点u尝试扩展
    		}
    		return res;
		}
		//*************************************************************/

例题：

1. [[POJ]1469 -- COURSES](http://poj.org/problem?id=1469)  
	题解：[二分图的最大匹配 - Hackbuteer1的专栏-博客频道 - CSDN.NET](http://blog.csdn.net/hackbuteer1/article/details/7398008)  
2. [[HDU]Problem - 2444](http://acm.hdu.edu.cn/showproblem.php?pid=2444)  
	题解：[【二分图】专题 - Lux- 博客频道 - CSDN.NET](http://blog.csdn.net/u013163567/article/details/40551875)
